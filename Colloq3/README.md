# Коллоквиум по поведенческим паттернам (нечётный вариант)

В этом репозитории три классических поведенческих паттерна на C++ и краткое обсуждение архитектуры ПО с учётом многопоточности.

---

## Структура

```
your-project/
├── README.md
├── src/
│   ├── command_example.cpp
│   ├── strategy_example.cpp
│   └── template_method_example.cpp
└── Makefile
```

- **src/** — примеры кода для каждого паттерна  
- **Makefile** — сборка трёх исполняемых файлов

---

## 1. Command

**Определение**  
Инкапсулирует запрос как объект с методами `execute()` и `undo()`, отделяя инициатора от исполнителя.

**Проблемы–решения**  
1. **GUI-меню**  
   - *Проблема*: каждый пункт меню по-разному обрабатывает клик  
   - *Решение*: для каждого пункта — объект `Command`, вызываемый единообразно  
2. **Undo/Redo**  
   - *Проблема*: вернуть или повторить прошлое действие  
   - *Решение*: хранить стек объектов-команд и вызывать `undo()`  
3. **Макросы**  
   - *Проблема*: выполнить цепочку действий одним вызовом  
   - *Решение*: собрать набор `Command` в «макрокоманду» и вызвать `execute()` разом

**Инкапсуляция**  
Команда скрывает детали действия за интерфейсом.

**Разделяй и властвуй**  
Создание, очередь и выполнение команд разнесены по модулям.

**Ортогональность**  
Новые команды добавляются без изменений в систему.

**Многопоточность**  
Команды можно ставить в потокобезопасную очередь и обрабатывать в отдельном потоке, синхронизируя доступ через `mutex` и `condition_variable`.

---

## 2. Strategy

**Определение**  
Определяет семейство алгоритмов, инкапсулирует каждый и делает их взаимозаменяемыми в рантайме.

**Проблемы–решения**  
1. **Сортировка**  
   - *Проблема*: разный объём и характер данных  
   - *Решение*: выбирать `QuickSort`, `MergeSort` или `HeapSort` через общий интерфейс  
2. **Шифрование**  
   - *Проблема*: разные уровни безопасности  
   - *Решение*: менять стратегию (`AES`, `RSA`, `DES`) без правок клиента  
3. **Компрессия**  
   - *Проблема*: разные форматы экспорта  
   - *Решение*: `ZIP`, `GZIP`, `LZW` как взаимозаменяемые стратегии

**Инкапсуляция**  
Каждый алгоритм скрыт в своём классе.

**Разделяй и властвуй**  
Контекст не знает деталей реализации — только интерфейс.

**Ортогональность**  
Алгоритмы можно добавлять или заменять без влияния друг на друга.

**Многопоточность**  
Каждому потоку можно дать свою стратегию или защищать общие объекты стратегий через синхронизацию.

---

## 3. Template Method

**Определение**  
Задаёт скелет алгоритма в базовом классе, делегируя реализацию шагов подклассам.

**Проблемы–решения**  
1. **Парсинг файлов**  
   - *Проблема*: разные форматы (CSV, XML, JSON)  
   - *Решение*: общий метод `parse()`, а шаги `readHeader()`, `readBody()`, `readFooter()` — в подпроцессорах  
2. **Игровой цикл**  
   - *Проблема*: повторяющийся цикл инициализации, обновления, рендеринга  
   - *Решение*: `run()` с последовательными хуками `initialize()`, `update()`, `render()`, `cleanup()`  
3. **Тестовые фреймворки**  
   - *Проблема*: однотипная подготовка, тест и очистка ресурсов  
   - *Решение*: в `TestCase` общий `execute()`, шаги `setUp()`, `runTest()`, `tearDown()`

**Инкапсуляция**  
Скелет алгоритма в одном месте, детали в подклассах.

**Разделяй и властвуй**  
Отделены общая структура и частные действия.

**Ортогональность**  
Новые шаги добавляются в подклассах без переработки каркаса.

**Многопоточность**  
Части алгоритма (`processData()`) могут запускаться в пуле потоков; нужно синхронизировать общий ресурс.

---

# Ответы на вопросы

## Архитектура ПО

**Что такое архитектура ПО**  
Архитектура ПО — это высокоуровневая структура системы, отражающая компоненты, их взаимосвязи, принципы проектирования и организацию данных и поведения. Архитектура задаёт:
- **Модули** (слои, сервисы, библиотеки) 
- **Контракты** (интерфейсы, API, сообщения)  
- **Связи** (направления вызовов, зависимости, взаимодействие)  
- **Нефункциональные требования** (производительность, надёжность, масштабируемость)

**Влияние многопоточности на архитектуру**  
- Выделение слоёв конкуренции, чтобы чётко продумать, какие компоненты работают в своих потоках (worker, UI, I/O) и как они взаимодействуют 
- Модель коммуникации в виде перехода на асинхронные каналы (очереди сообщений, publish/subscribe), чтобы избежать блокировок межкомпонентных вызовов
- Архитектурные решения должны минимизировать критические секции, использовать immutable-объекты, транзакции или lock-free структуры  
- Многопоточная архитектура закладывает горизонтальное разделение работы — thread pool, actor model, reactive-подходы 
- Нужно проектировать компоненты так, чтобы их логику можно было тестировать в однопоточном режиме, а затем «включать» многопоточность для нагрузочного теста


---

## Сборка и запуск

```bash
make         
./command_example
./strategy_example
./template_method_example

make clean 
```
