# Сидорская Дарья, 1 вариант

---

#### 1. **WinAPI, используемое в Лабораторной работе №3**
Для реализации синхронизации потоков и управления ресурсами в Windows применяются следующие функции WinAPI:
- **CreateThread**: Создание потоков.
  ```cpp
  HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
  ```
  Пример: 
  ```cpp
  HANDLE hThread = CreateThread(NULL, 0, markerThread, (LPVOID)threadId, 0, NULL);
  ```
- **CreateEvent**: Создание объекта "событие".
  ```cpp
  HANDLE CreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCTSTR lpName);
  ```
  Пример: 
  ```cpp
  HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL); // Автоматический сброс
  ```
- **WaitForMultipleObjects**: Ожидание сигналов от нескольких объектов синхронизации.
  ```cpp
  DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE* lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
  ```
  Пример: 
  ```cpp
  WaitForMultipleObjects(numThreads, hThreads, TRUE, INFINITE); // Ожидание завершения всех потоков
  ```
- **SetEvent** и **ResetEvent**: Установка и сброс события.
  ```cpp
  SetEvent(hEvent); // Сигнал о готовности
  ResetEvent(hEvent); // Сброс события
  ```
- **EnterCriticalSection** и **LeaveCriticalSection**: Работа с критическими секциями.
  ```cpp
  CRITICAL_SECTION cs;
  InitializeCriticalSection(&cs);
  EnterCriticalSection(&cs); // Захват секции
  LeaveCriticalSection(&cs); // Освобождение
  ```

---

#### 2. **Поток в ОС Windows**
**Поток** — это наименьшая единица исполнения в Windows. Каждый поток:
- Имеет собственный стек, регистры и счетчик команд.
- Разделяет ресурсы процесса (память, файлы) с другими потоками.
- Управляется планировщиком ОС.

Пример из лабораторной:  
Потоки `marker` работают параллельно, изменяя общий массив. Их выполнение контролируется через события и критические секции.

---

#### 3. **Мьютекс**
**Мьютекс** (Mutual Exclusion) — объект синхронизации, обеспечивающий эксклюзивный доступ к ресурсу. Отличается от критической секции:
- Может использоваться между процессами.
- Поддерживает время ожидания.
  
Пример использования:
```cpp
HANDLE hMutex = CreateMutex(NULL, FALSE, NULL);
WaitForSingleObject(hMutex, INFINITE); // Захват мьютекса
// Работа с ресурсом
ReleaseMutex(hMutex); // Освобождение
```

---

#### 4. **Событие (Event)**
**Событие** — объект синхронизации, уведомляющий потоки о наступлении условия. Типы:
- **Автоматический сброс**: Сигнал сбрасывается после пробуждения одного потока.
- **Ручной сброс**: Сигнал сохраняется, пока не будет сброшен вручную.

Пример из лабораторной:  
Поток `main` использует событие для старта потоков `marker`:
```cpp
SetEvent(startEvent); // Сигнал "начать работу"
```
Потоки `marker` сигнализируют о невозможности продолжения:
```cpp
SetEvent(pauseEvent); // Уведомление main
WaitForSingleObject(resumeEvent, INFINITE); // Ожидание ответа
```

---

#### 5. **Сравнение C++98 и C++11/17 (в контексте лабораторных)**
| **Аспект**              | **C++98**                                  | **C++11/17**                              |
|-------------------------|--------------------------------------------|-------------------------------------------|
| Многопоточность         | Нет встроенной поддержки. Используется WinAPI: `CreateThread`, `WaitForSingleObject`. | Введены `std::thread`, `std::mutex`, `std::condition_variable`. |
| Синхронизация           | Критические секции и события через WinAPI. | `std::lock_guard`, `std::unique_lock`, атомарные операции. |
| Безопасность            | Риск утечек ресурсов (например, неосвобожденный мьютекс). | RAII-обертки автоматически управляют ресурсами. |

Пример кода для C++11:
```cpp
#include <thread>
#include <mutex>
std::mutex mtx;
void markerThread(int id) {
    std::lock_guard<std::mutex> lock(mtx); // Автоматический захват и освобождение
    // Работа с общим массивом
}
```

**Итог**: C++11+ упрощает многопоточность, делая код переносимым и менее подверженным ошибкам.


---


# Общие вопросы:

### 1) **Что такое ООП? – полное определение**

**Объектно-ориентированное программирование (ООП)** — это парадигма программирования, которая основывается на концепции объектов. Объект представляет собой экземпляр класса, который инкапсулирует данные и методы для работы с этими данными. Основные принципы ООП:

- **Инкапсуляция**: Сокрытие деталей реализации и представление только необходимого интерфейса. Это позволяет уменьшить сложность системы и повысить безопасность данных.
  Пример: В Лабораторной работе №3 данные о состоянии массива хранятся в объектах, а доступ к этим данным осуществляется через методы, что скрывает сложность работы с ними.
  
- **Наследование**: Позволяет создавать новые классы на основе существующих, повторно используя код.
  Пример: Класс потока `marker` может наследовать общие функции для работы с массивом и синхронизацией.

- **Полиморфизм**: Возможность использования одного интерфейса для различных типов данных. Это позволяет делать программы более гибкими.
  Пример: В коде программы можно использовать общее имя для разных типов объектов (например, разные типы потоков), при этом поведение этих объектов будет зависеть от их типа.

- **Абстракция**: Процесс выделения только существенных характеристик объекта, скрывая второстепенные детали.
  Пример: В Лабораторной работе важно создать абстракцию для работы с потоком, чтобы не задумываться о деталях его реализации, а использовать общий интерфейс.

---

### 2) **Магическое число 7 Миллера? – привести не менее 7 примеров из IT**

**Магическое число 7 Миллера** — это гипотеза, предложенная психологом Джорджем Миллером в 1956 году, согласно которой человек может воспринимать и удерживать в краткосрочной памяти около 7 (плюс-минус 2) объектов одновременно. В контексте IT это число также имеет значение:

1. **Максимальное количество вкладок в браузере** — Психологический предел для эффективного переключения между задачами.
2. **Число потоков** — Когда количество потоков в приложении превышает 7, становится сложнее управлять ими без значительных накладных расходов.
3. **Размер пакета данных в TCP** — Некоторые исследования показывают, что пакеты данных размером около 7 сообщений оптимальны для работы в сети с минимальными задержками.
4. **Число элементов в меню** — Для улучшения юзабилити меню в интерфейсах обычно ограничивают до 7 элементов.
5. **Число параметров функции** — В функциональном программировании часто ограничивают количество аргументов функции, чтобы упростить поддержку.
6. **Сложность паролей** — Психологически легче запомнить пароль, состоящий из 7 символов, чем более длинный.
7. **Число этапов в процессе разработки** — В методологиях разработки часто выделяется не более 7 крупных этапов для упрощения управления проектом.

---

### 3) **Энтропия ПО? – привести не менее 5 примеров негэнтропийных мер при разработке ПО**

**Энтропия ПО** описывает уровень неопределенности или беспорядка в программном обеспечении. Чем выше энтропия, тем сложнее поддерживать, тестировать и развивать систему. Примеры негэнтропийных мер:

1. **Модульность**: Разделение программы на независимые модули снижает сложность и делает код более читаемым и расширяемым.
2. **Использование шаблонов проектирования**: Применение общепринятых решений для типовых задач позволяет снизить неопределенность и улучшить структуру кода.
3. **Документирование кода**: Хорошо документированный код снижает неопределенность и помогает разработчикам понимать, как и зачем были приняты решения.
4. **Тестируемость**: Код, который легко покрывается юнит-тестами, имеет меньшую энтропию, так как его функциональность и поведение более предсказуемы.
5. **Использование стилей кодирования**: Применение согласованных стилей кодирования снижает неопределенность в том, как должен быть организован и оформлен код.

---

### 4) **5 признаков сложной системы по Гради Бучу – по каждому признаку привести не менее 2-х пояснительных примеров из Ваших Лабораторных работ или pet проектов**

**Гради Буч** выделяет 5 признаков сложной системы:

1. **Невозможность предсказать поведение системы на основе описания её компонентов**:
   - В Лабораторной работе №3 поведение потоков зависит от случайных чисел, и предсказать точно, какой поток и в какой момент изменит элемент массива, невозможно.
   - В pet проекте, где работает несколько взаимозависимых API, сложно предсказать, как будет взаимодействовать система, если одно из API изменит свои данные.

2. **Эмерджентность**: Поведение системы не сводится к поведению её компонентов.
   - В Лабораторной работе №3, когда несколько потоков одновременно пытаются изменять один и тот же элемент массива, возникает состояние гонки, которое не может быть предсказано, основываясь только на поведении отдельных потоков.
   - В другом проекте с микросервисной архитектурой, взаимодействие между сервисами создает неожиданные результаты, такие как задержки или утечки данных.

3. **Невозможность упростить систему без потери её функциональности**:
   - В Лабораторной работе нельзя упростить процесс синхронизации потоков, так как без неё потоки могут вмешиваться в работу друг друга.
   - В проекте на базе многозадачного API упрощение синхронизации потоков без потери функционала может нарушить логику работы с данными.

4. **Высокий уровень взаимозависимости между компонентами системы**:
   - В Лабораторной работе потоки не могут работать независимо — каждый из них зависит от сигналов других потоков для продолжения работы.
   - В проекте, где различные модули зависят от состояния других, например, модуль данных зависит от модулей обработки и визуализации, что делает систему сложной для управления.

5. **Сложность контроля над системой в реальном времени**:
   - В Лабораторной работе с потоками сложно отслеживать выполнение каждого потока в реальном времени, поскольку они выполняются параллельно.
   - В большом проекте с асинхронными задачами управление состоянием системы и отладка работы в реальном времени становится сложным.

---

### 5) **Закон иерархических компенсаций Седова – привести не менее 5 исторических примеров применения закона Седова в эволюции IT сферы**

Закон иерархических компенсаций Седова гласит, что система развивается через серию компенсаций, когда новые решения или подходы компенсируют ограничения старых систем. Примеры из IT:

1. **Переход от монолитных приложений к микросервисам**: Вначале микросервисная архитектура решила проблему масштабируемости и гибкости, компенсируя сложности в управлении и синхронизации.
2. **Переход от однопоточных к многозадачным системам**: Многозадачность и многопоточность были введены, чтобы компенсировать ограничения однопоточной обработки.
3. **От прямого взаимодействия с оборудованием к абстракциям ОС**: Ранее программисты писали код, напрямую взаимодействуя с железом, что было трудно управляемо. Введение операционных систем и абстракций компенсировало эту проблему.
4. **Использование виртуализации для повышения эффективности серверов**: Виртуализация компенсировала проблемы с использованием ресурсов серверов, позволив запускать несколько виртуальных машин на одном физическом сервере.
5. **От традиционного SQL к NoSQL**: Переход к NoSQL базам данных был ответом на ограничения реляционных СУБД в плане масштабируемости и гибкости.

Эти примеры показывают, как новые технологические решения отвечают на ограничения предыдущих подходов.

